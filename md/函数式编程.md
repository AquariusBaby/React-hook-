#函数式编程
---
函数式编程（ Functional Programming，简称 FP）
> 于我个人而言，函数式编程就像第三次工业革命，前两次分别为命令式编程（Imperative programming）和面向对象编程（Object Oriented Programming）。
1. what is FP?
2. why is FP?
3. how use FP?
---

 [参考文章: 网易云音乐的函数式编程——入门篇](https://zhuanlan.zhihu.com/p/81302150)

##什么是函数式编程?

 - 其实函数我们从小就学，什么一次函数，二次函数……根据学术上函数的定义，函数即是一种描述集合和集合之间的转换关系，输入通过函数都会返回有且只有一个输出值。 

 - 所以，函数实际上是一个关系，或者说是一种映射，而这种映射关系是可以组合的，一旦我们知道一个函数的输出类型可以匹配另一个函数的输入，那他们就可以进行组合。

 - 在我们的编程世界中，我们需要处理的其实也只有“数据”和“关系”，而关系就是函数。我们所谓的编程工作也不过就是在找一种映射关系，一旦关系找到了，问题就解决了，剩下的事情，就是让数据流过这种关系，然后转换成另一个数据罢了。

 - 它其实就是强调在编程过程中把更多的关注点放在如何去构建关系。通过构建一条高效的建流水线，一次解决所有问题。而不是把精力分散在不同的加工厂中来回奔波传递数据。

####函数式编程的特点

#####我们经常会说到函数是”一等公民“(First-Class Functions)

这是函数式编程得以实现的前提，因为我们基本的操作都是在操作函数。这个特性意味着函数与其他数据类型一样，是平等的，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为其他函数的返回值；

#####声明式编程 (Declarative Programming)

 - 函数式编程大多时候都是在声明我需要做什么，而非怎么去做。
 - 这种编程风格称为 声明式编程 。这样有个好处是代码的可读性特别高，因为声明式代码大多都是接近自然语言的，同时，它解放了大量的人力，因为它不关心具体的实现，因此它可以把优化能力交给具体的实现，这也方便我们进行分工协作。

 1. SQL语句就是声明式的，你无需关心 Select 语句是如何实现的，不同的数据库会去实现它自己的方法并且优化。
 2. React 也是声明式的，你只要描述你的 UI，接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠你自己去渲染和优化 diff 算法。

#####惰性执行（Lazy Evaluation）

所谓惰性执行指的是函数只在需要的时候执行，即不产生无意义的中间变量。

#####无状态和数据不可变 (Statelessness and Immutable data)

这是函数式编程的核心概念：

 - **数据不可变**：它要求你所有的数据都是不可变的，这意味着如果你想要修改一个对象，你应该创建一个新的对象来修改，而不是修改原有的对象。
 - **无状态**：主要是强调对于一个函数，不管你何时运行，它都像第一次运行一样，给定相同的输入，给出相同的输出，完全不依赖外部状态的变化。

所以为了实现这一目标，函数式编程提出函数应该具备的特性：**没有副作用和纯函数**

#####没有副作用（No Side Effects）

它的含义是：在完成函数主要功能之外完成的其他副要功能。

在我们函数中最主要的功能当然是根据输入返回结果，而在函数中我们最常见的副作用就是随意操纵外部变量。由于 JS 中对象传递的是引用地址，哪怕我们用 const 关键词声明对象，它依旧是可以变的。而正是这个“漏洞”让我们有机会随意修改对象。

保证函数没有副作用，一来能保证数据的不可变性，二来能避免很多因为共享状态带来的问题。

当你一个人维护代码时候可能还不明显，但随着项目的迭代，项目参与人数增加，大家对同一变量的依赖和引用越来越多，这种问题会越来越严重。最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生 Bug。

> 传递引用一时爽，代码重构火葬场

#####纯函数 (pure functions)

纯函数算是在 “没有副作用” 的要求上再进一步了。

纯函数的概念很简单就是两点：
 - 不依赖外部状态（无状态）：函数的运行结果不依赖全局变量，this指针、IO操作等。
 - 没有副作用（数据不变）：不修改全局变量，永远会得到相同的输出。

所以纯函数才是真正意义上的 “函数”， 它意味着相同的输入，永远会得到相同的输出。

我们这么强调使用纯函数，纯函数的意义是什么？
 - 便于测试和优化：由于纯函数对于相同的输入永远会返回相同的结果，因此我们可以轻松断言函数的执行结果，同时也可以保证函数的优化不会影响其他代码的执行。这十分符合测试驱动开发 TDD（Test-Driven Development ) 的思想，这样产生的代码往往健壮性更强。
 - 可缓存性：因为相同的输入总是可以返回相同的输出，因此，我们可以提前缓存函数的执行结果，有很多库有所谓的 memoize 函数。

    ```
    function memoizeFn(fn) {
        let cache = {};

        return function(...arg) {
            let key = JSON.stringify(arg);
            let value = cache[key];

            if (!value) {
                value = fn(...arg);
                cache[key] = value;
            }
            return value;
        }
    }
    ```
 - 自文档化：由于纯函数没有副作用，所以其依赖很明确，因此更易于观察和理解。
 - 更少的 Bug：使用纯函数意味着你的函数中不存在指向不明的 this，不存在对全局变量的引用，不存在对参数的修改，这些共享状态往往是绝大多数 bug 的源头。

####流水线的构建

如果函数式编程中有两种操作是必不可免的那无疑就是**柯里化（Currying）** 和 **函数组合（Compose）**，柯里化其实就是流水线上的加工站，函数组合就是我们的流水线，它由多个加工站组成。