# useMemo
---

接受一个 <u>创建函数</u> 和 <u>依赖项数组</u> 作为参数，返回一个 <u>memoized</u>值；只有在依赖项发生改变的时候，才会重新调用此函数，返回一个新的值。

```javascript
const memoized = useMemo(() => computedExpensiveValue(a, b), [a, b])
```

> * 注意，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。
> * 你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。

作用：
1. 父子组件传值带来的性能优化：缓存一些引用类型，减少每次父级渲染给子组件带来的不必要的re-render；
2. 可以把一些 **昂贵的计算逻辑** 放到 useMemo 中；